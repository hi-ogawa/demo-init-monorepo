// Generated by CoffeeScript 1.6.3
var Stringifier, stream, util;

stream = require('stream');

util = require('util');

Stringifier = function(options) {
  if (options == null) {
    options = {};
  }
  stream.Transform.call(this, options);
  this.options = options;
  this.options.delimiter = ',';
  this.options.quote = '"';
  this.options.quoted = false;
  this.options.escape = '"';
  this.options.columns = null;
  this.options.header = false;
  this.options.lineBreaks = null;
  this.options.flags = 'w';
  this.options.encoding = 'utf8';
  this.options.newColumns = false;
  this.options.end = true;
  this.options.eof = false;
  this.count = 0;
  this.countWriten = 0;
  return this;
};

util.inherits(Stringifier, stream.Transform);

Stringifier.prototype.write = function(chunk, encoding, callback) {
  var e, preserve;
  if (chunk == null) {
    return;
  }
  preserve = typeof chunk !== 'object';
  if (!preserve) {
    try {
      this.emit('record', chunk, this.count - 1);
    } catch (_error) {
      e = _error;
      return this.emit('error', e);
    }
    chunk = this.stringify(chunk);
  }
  if (typeof chunk === 'number') {
    chunk = "" + chunk;
  }
  if (!preserve) {
    this.countWriten++;
  }
  return stream.Transform.prototype.write.call(this, chunk);
};

Stringifier.prototype._transform = function(chunk, encoding, callback) {
  this.push(chunk);
  return callback();
};

/*

`Stringifier(line)`
-------------------

Convert a line to a string. Line may be an object, an array or a string.
*/


Stringifier.prototype.stringify = function(line) {
  var column, columns, containsLinebreak, containsQuote, containsdelimiter, delimiter, escape, field, i, newLine, quote, regexp, _i, _j, _line, _ref, _ref1;
  if (typeof line !== 'object') {
    return line;
  }
  columns = this.options.columns;
  if (typeof columns === 'object' && columns !== null && !Array.isArray(columns)) {
    columns = Object.keys(columns);
  }
  delimiter = this.options.delimiter;
  quote = this.options.quote;
  escape = this.options.escape;
  if (!Array.isArray(line)) {
    _line = [];
    if (columns) {
      for (i = _i = 0, _ref = columns.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        column = columns[i];
        _line[i] = typeof line[column] === 'undefined' || line[column] === null ? '' : line[column];
      }
    } else {
      for (column in line) {
        _line.push(line[column]);
      }
    }
    line = _line;
    _line = null;
  } else if (columns) {
    line.splice(columns.length);
  }
  if (Array.isArray(line)) {
    newLine = this.countWriten ? this.options.rowDelimiter || "\n" : '';
    for (i = _j = 0, _ref1 = line.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      field = line[i];
      if (typeof field === 'string') {

      } else if (typeof field === 'number') {
        field = '' + field;
      } else if (typeof field === 'boolean') {
        field = field ? '1' : '';
      } else if (field instanceof Date) {
        field = '' + field.getTime();
      }
      if (field) {
        containsdelimiter = field.indexOf(delimiter) >= 0;
        containsQuote = field.indexOf(quote) >= 0;
        containsLinebreak = field.indexOf("\r") >= 0 || field.indexOf("\n") >= 0;
        if (containsQuote) {
          regexp = new RegExp(quote, 'g');
          field = field.replace(regexp, escape + quote);
        }
        if (containsQuote || containsdelimiter || containsLinebreak || this.options.quoted) {
          field = quote + field + quote;
        }
        newLine += field;
      }
      if (i !== line.length - 1) {
        newLine += delimiter;
      }
    }
    line = newLine;
  }
  return line;
};

module.exports = function() {
  return new Stringifier();
};

module.exports.Stringifier = Stringifier;
